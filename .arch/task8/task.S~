# Функции as , вызываемые из С
	
.globl	Numbers	# имя, ОПРЕДЕЛЕННОЕ вне этого исходного файла
    
.text # секция команд процесора
## ---------------------------------------------------------------------
.type Make_Sum, @function

.globl Make_Sum
	
Make_Sum:
	#Читает <Параметр1> чисел из массива <Параметр2>
	
	# Пролог------------------------------------------------------
	pushl %ebp 	 # сохранить в стеке значение, бывшее в вызывающей
	movl  %esp, %ebp # обеспечить адресный доступ к параметрам и
			 # локальным переменнным в стеке путем базовой 
			 # адресации через ebp	
	## ---------------------------------------------------------
	# Получаем параметры со стека
	movl 8(%ebp), %ebx	# Первый параметр в %ebx(кол-во элементов)
	movl 12(%ebp), %esi	# Второй параметр в %esi(Адресс массива)

	xorl %ecx, %ecx
	xorl %eax, %eax
Sum_Begin:
	movl (%esi,%ecx,4), %edx #Переписываем элемент в %edx

	addl %edx, %eax		# Прибаляем %edx к  %eax (результат в %eax)
	
	incl %ecx		# Увеличиваем счётчик на 1
	
	cmpl %ecx, %ebx		# Прошли все элементы?
	jne Sum_Begin		# Нет, переходим к следующему
	# Эпилог -------------------------------------------------

	movl %ebp, %esp # восстановить указатель стека
	popl %ebp       # восстановить ebp
	ret		# возврат в вызывающую
	

## ---------------------------------------------------------------------
.type	Read_Sym, @function	# функция циклической обработки массива
.globl	Read_Sym		# имя может ИСПОЛЬЗОВАТЬСЯ вне этого исх. файла
Read_Sym:

/*
	Читает <Параметр1> символов из массива <Параметр2>
	и передает их на обработку функции Trans_Sym.
	Результат размещается в массив Numbers
*/

	# Стандартный пролог фунции
	
	pushl %ebp 	 # сохранить в стеке значение, бывшее в вызывающей
	movl  %esp, %ebp # обеспечить адресный доступ к параметрам и
			 # локальным переменнным в стеке путем базовой 
			 # адресации через ebp
	                 
	subl  $4, %esp	 # завести 4-х байтовую локальную переменную 

	# Тело функции

	subl %ecx, %ecx   # инициализация счетчика цикла	
NextSym:	
	movl 12(%ebp), %edx  # адрес второго параметра-массива в edx

	# вызов функции Trans_Sym	
	
	subl %ebx, %ebx	     	    # подготовка ebx для записи символа
	movb (%edx,%ecx,1), %bl     # символ в ebx

	# Начинаем вызов Trans_Sym

	pusha		# сохранить регистры текущей функции Read_Sym	

	pushl %ebx  	# Параметр функции Trans_Sym (код 
			# символа из массива) в стек
	
	call Trans_Sym

	addl $4,%esp	# очистить стек от параметров Trans_Sym

	movl %eax, Numbers(,%ecx,4) 	# записать результат Trans-Sym

	popa	# восстановть регистры Read_Sym		
	
	incl %ecx	     # наращиваем счетчик цикла
	cmpl 8(%ebp), %ecx   # счетчик равен первому параметру?
	jne NextSym	     # НЕТ, повторяем
			     # Да - выходим из цикла

	# Стандартный эпилог функции

	movl %ebp, %esp # восстановить указатель стека
	popl %ebp       # восстановить ebp
	ret		# возврат в вызывающую
	
	# конец Read_Sym

/*
    Функция преобразования кода символа в числовое значение
    <Пареметр1> преобразуется в число и возвращается в eax    
*/
	
.type	Trans_Sym, @function  	
.globl Trans_Sym
Trans_Sym:

	# Стандартный пролог фунции

	pushl %ebp 	 # сохранить в стеке значение, бывшее в вызывающей
	movl  %esp, %ebp # обеспечить адресный доступ к параметрам и 
			 # локальным переменнным в стеке путем базовой 
			 # адресации через ebp

	# тело функции

	movl 8(%ebp), %eax  # параметр в eax
	subl $'0', %eax    # получение числового значения	

	# Стандартный эпилог функции

	movl %ebp, %esp # восстановить указатель стека
	popl %ebp       # восстановить ebp
	ret		# возврат в вызывающую

.end
