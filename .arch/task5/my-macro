/* Макроопределение завершения работы */

.macro Finish
    movl $0, %ebx 	# first argument: exit code
    movl $1, %eax 	# sys_exit index
    int  $0x80 		# kernel interrupt
.endm


/* 
 * Макроопределение завершения работы.
 * Аргументы:
 * 	- код завершения программы
 *
 * После выполнения макровызова изменяются регистры: %eax, %ebx
 * См. также 'man 2 exit'
*/
.macro Exit ret_val
	movl $1, %eax 		# номер сист. вызова exit
	movl \ret_val, %ebx 	# код выхода
	int $0x80 		# выполнить системный вызов
.endm


/*
 * Мароопределение для процедуры считывания одного символа из стандартного ввода
 * Аргументы:
 * 	- адрес буффера для считывания символа
 * Результат:
 *	- в %eax количество считанных символов
 *	- по адресу buf_addr - считанный символ
 * 
 * После выполнения макровызова изменяются регистры: %eax, %ebx, %ecx, %edx
 * См. также 'man 2 read'
*/
.macro Getchar buf_addr
	movl $3, %eax		# номер сист. вызова read
	movl $0, %ebx		# параметр 1: дескриптор стандартного ввода
	movl \buf_addr, %ecx	# параметр 2: адрес буфера (он же - фактический 
	     			# параметр макровызова)
	movl $1, %edx		# параметр 3: количество байтов для чтения
	int $0x80		# выполнить системный вызов
.endm

/*
 * Мароопределение для процедуры вывода строки в стандартный вывод
 * Аргументы:
 * 	- Строка для вывода.
 *
 * Приметр макровызова:
 *	Puts "Текст выводимой строки" 
 *
 * Результат:
 *	- выводит в стандартный вывод символы заданной строки,
 *	  а также символ перевода строки
 *	
 * После выполнения макровызова изменяются регистры: %eax, %ebx, %ecx, %edx
 * См. также 'man puts', 'man 2 write'
*/
.macro Puts string
.data
    str\@: 	.ascii "\string"  # формирование фактической строки для вывода
	
    strlen\@ = 	. - str\@           # получение значения длины строки

.text
	movl $4, %eax		# номер сист. вызова write
	movl $1, %ebx		# параметр 1: дескриптор стандартного вывода	
	movl $str\@, %ecx	# параметр 2: адрес памяти с выводимыми символами
	movl $strlen\@, %edx 	# параметр 3: количество байтов для вывода
	int $0x80		# выполнить системный вызов
.endm

.macro ToString10 Numb

        movw $10, %bx           # Система счисления. На неё будем делить
        movl $4, %esi           # Адрес самого первого чила. В числе не может быть больше 5 чисел, поэтому устанавливаем смещение на 4
        movw \Numb, %ax         # Копируем номер в %ax
        xorl %edi, %edi         # Обнуляем %edi

ToStr10_begin\@:                        # Начало цикла
        movl $0, %edx           # Обнуляем %edx (В нём после операции будет остаток)
        divw %bx                # Делим %ax на %bx, остаток в %dx
        addb $0x30, %dl         # Прибавляем к %dl 0x30, чтобы перейти к коду числа. Остаток влезает в %dl потому что делим на 10(Отсекается 1 число).
        movb %dl, out(%esi)     # Копируем содержимое %dl в буфер по нужному смещению

        cmpw $0, %ax            # Дошли до нуля? (В %ax пусто?)
        je ToStr10_memcpy\@       # Да, заканчиваем преобразование

        decl %esi               # Нет, уменьшаем %esi на 1
        jmp ToStr10_begin\@       # и переходим в начало цикла

ToStr10_memcpy\@:
        cmpl  $5, %esi          # В %esi 5?
        je ToStr10_end\@          # Да, выходим

        movb out(%esi), %al # Копируем байт по адресу  String(%esi) в %al

        movb $0, out(%esi)  # Записываем 0 по адресу String(%esi)
        movb %al, out(%edi) # Записываем значение %al по адресу String(%edi)
        inc %esi                # Увеличиваем %esi на 1
        inc %edi                # Увеличиваем %edi на 1
        jmp ToStr10_memcpy\@    # Переходим в начало цикла

ToStr10_end\@:
        movb $0, out(%edi)
        Write out
        movw $0, summ
.endm

