/* 
 * Макроопределение завершения работы.
 * Аргументы:
 * 	- код завершения программы
 *
 * После выполнения макровызова изменяются регистры: %eax, %ebx
 * См. также 'man 2 exit'
*/
.macro Exit ret_val
	movl $1, %eax 		# номер сист. вызова exit
	movl \ret_val, %ebx 	# код выхода
	int $0x80 		# выполнить системный вызов
.endm


/*
 * Мароопределение для процедуры считывания одного символа из стандартного ввода
 * Аргументы:
 * 	- адрес буффера для считывания символа
 * Результат:
 *	- в %eax количество считанных символов
 *	- по адресу buf_addr - считанный символ
 * 
 * После выполнения макровызова изменяются регистры: %eax, %ebx, %ecx, %edx
 * См. также 'man 2 read'
*/
.macro Getchar buf_addr
	movl $3, %eax		# номер сист. вызова read
	movl $0, %ebx		# параметр 1: дескриптор стандартного ввода
	movl \buf_addr, %ecx	# параметр 2: адрес буфера (он же - фактический 
	     			# параметр макровызова)
	movl $1, %edx		# параметр 3: количество байтов для чтения
	int $0x80		# выполнить системный вызов
.endm

/*
 * Мароопределение для процедуры вывода строки в стандартный вывод
 * Аргументы:
 * 	- Строка для вывода.
 *
 * Приметр макровызова:
 *	Puts "Текст выводимой строки" 
 *
 * Результат:
 *	- выводит в стандартный вывод символы заданной строки,
 *	  а также символ перевода строки
 *	
 * После выполнения макровызова изменяются регистры: %eax, %ebx, %ecx, %edx
 * См. также 'man puts', 'man 2 write'
*/
.macro Puts string
.data
    str\@: 	.ascii "\string\n"  # формирование фактической строки для вывода
	
    strlen\@ = 	. - str\@           # получение значения длины строки

.text
	movl $4, %eax		# номер сист. вызова write
	movl $1, %ebx		# параметр 1: дескриптор стандартного вывода	
	movl $str\@, %ecx	# параметр 2: адрес памяти с выводимыми символами
	movl $strlen\@, %edx 	# параметр 3: количество байтов для вывода
	int $0x80		# выполнить системный вызов
.endm

# Макрос для подсчёта длинны строки(результат в %edx). Концом строки считается \0 
.macro Strlen str
	xorl %edx, %edx		# Обнуляем %edx.

strlen_begin\@:
	
	movb \str(%edx), %al	# Копируем байт строки в %al.
	cmpb $0, %al		# Символ конца строки?
	je strlen_end\@		# Да, выходим.
	incl %edx		# Нет, увеличиваем %edx на 1 ...
	jmp strlen_begin\@	# и переходим в начало цикла
	
strlen_end\@:	
.endm

# Макрос вывода строки на экран.
.macro Write string

	Strlen \string
	movl $4, %eax		# номер сист. вызова write
	movl $1, %ebx		# параметр 1: дескриптор стандартного вывода	
	movl $\string, %ecx	# параметр 2: адрес памяти с выводимыми символами
	int $0x80		# выполнить системный вызов
.endm

# Макрос перевода числа в строку с основанием 10. Number - число(2 байта), String буфер, куда помещаеся строка(6 байт)
.macro ToString10 Number, String

	movw $10, %bx		# Система счисления. На неё будем делить
	movl $4, %esi		# Адрес самого первого чила. В числе не может быть больше 5 чисел, поэтому устанавливаем смещение на 4
	movw \Number, %ax	# Копируем номер в %ax
	xorl %edi, %edi		# Обнуляем %edi

ToStr2b_begin\@:		  	# Начало цикла
	movl $0, %edx		# Обнуляем %edx (В нём после операции будет остаток)
	divw %bx		# Делим %ax на %bx, остаток в %dx
   	addb $0x30, %dl		# Прибавляем к %dl 0x30, чтобы перейти к коду числа. Остаток влезает в %dl потому что делим на 10(Отсекается 1 число).
	movb %dl, \String(%esi)	# Копируем содержимое %dl в буфер по нужному смещению

	cmpw $0, %ax		# Дошли до нуля? (В %ax пусто?)
	je ToStr2b_memcpy\@	# Да, заканчиваем преобразование

	decl %esi		# Нет, уменьшаем %esi на 1
	jmp ToStr2b_begin\@	# и переходим в начало цикла

ToStr2b_memcpy\@:	
	cmpl  $5, %esi		# В %esi 5?
	je ToStr2b_end\@	# Да, выходим
	
	movb \String(%esi), %al # Копируем байт по адресу  String(%esi) в %al
	movb $0, \String(%esi)	# Записываем 0 по адресу String(%esi)
	movb %al, \String(%edi)	# Записываем значение %al по адресу String(%edi)
	inc %esi		# Увеличиваем %esi на 1
	inc %edi		# Увеличиваем %edi на 1
	jmp ToStr2b_memcpy\@	# Переходим в начало цикла

ToStr2b_end\@:
.endm
